# -*- coding: utf-8 -*-
"""App.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Hg4QCsbuTSRtIdaMGIu1yFUwTKlOWoUr
"""

import dash
import boto3
import os
import time
from botocore.exceptions import NoCredentialsError, ClientError
# import nbimporter
from datetime import datetime
import dash_bootstrap_components as dbc
from dash import Input, Output, dcc, html, dash_table, callback, State
import pandas as pd
from leadsquared import clean_leadsquared_data,data_read
import plotly.express as px
import plotly.graph_objs as go
from bivariate_call_lead import call_Visualisation, generate_cross_table_call_app
from bivariate_prediction import PredictedBivariateAnalysis, generate_cross_table_closed, generate_cross_table_wip,bivariate_wip_predicted

app = dash.Dash(external_stylesheets=[dbc.themes.BOOTSTRAP], suppress_callback_exceptions=True)


S3_BUCKET = "ayurvaidleadscoringmodel"
S3_REGION = "ap-south-1"
CONFUSION_MATRIX_FOLDER = "version2/assets/Confusion Matrix"

# Load data
df_call_final=pd.read_csv('https://ayurvaidleadscoringmodel.s3.ap-south-1.amazonaws.com/version2/LeadSquared+Data/final_data.csv')
print("Columns in Call data:",df_call_final['Appointment Fixed?'].value_counts())

mappings={
    "Dr Ajithkumar  Vivekanandan(AVHVN)":'Dr Ajithkumar V',
    'Dr Ajithkumar V (AHLL-KP)':'Dr Ajithkumar V',
    'Dr Shrinivasa Pandey-AVND':'Dr Shrinivasa Pandey',
    'Dr Nagendra Kumar (HRBR)':'Dr Nagendra',
    'Dr Shrinivasa Pandey-AVND':'Dr Shrinivasa Pandey',
    'Dr Smitha Jayadev (AHLL-KP)':'Dr Smitha Jayadev',
    'Dr Smitha Jayadev (AHLL-KP)':'Dr Smitha Jayadev',
    'Dr Smitha Jayadev(AHLL-KP)':'Dr Smitha Jayadev',
    'Dr Supraja Reddy (AVND)':'Dr Supraja Reddy',
    'Dr Susmitha C (AHLL-KP)':'Dr Susmitha C',
    'Dr Swetha Suvarna (HRBR)':'Dr Swetha Suvarna',
    'Dr Swetha Suvarna-AVDW':'Dr Swetha Suvarna',
    'Dr Tinkle Rani (AVND)':'Dr Tinkle Rani',
    'Dr Tinkle Rani(AVND)':'Dr Tinkle Rani',
    'Dr Vimarsha S(Diva)':'Dr Vimarsha S',
    'Dr Zankhana Buch-BG Road':'Dr. Zankhana Buch',
    'Dr. Aishwarya Chand (AVHR)':'Dr. Aishwarya Chand',
    'Dr. Aishwarya Chand(HRBR)':'Dr. Aishwarya Chand',
    'Dr. Aishwarya Lakshmi (AVHD)':'Dr. Aishwarya Lakshmi',
    'Dr. Aishwarya Lakshmi (SSAVCIO)':'Dr. Aishwarya Lakshmi',
    'Dr. Anagha J (AVND)':'Dr. Anagha J',
    'Dr. Anooj Chakrapani (AVM)':'Dr. Anooj Chakrapani',
    'Dr. Ashima Sardana (AVM)':'Dr. Ashima Sardana',
    'Dr. Aswathi (AVM)':'Dr. Aswathi',
    'Dr. Aswathi (AVND)':'Dr. Aswathi',
    'Dr. Aswathi AT (AVM)':'Dr. Aswathi A T',
    'Dr. Bheema Bhatta (AVM)':'Dr. Bheema Bhatta',
    'Dr. Bheema Bhatta (AVM)':'Dr. Bheema Bhatta',
    'Dr. Bheema Bhatta (AVND)':'Dr. Bheema Bhatta',
    'Dr. Bheema Bhatta-AVND':'Dr. Bheema Bhatta',
    'Dr. Byresh Appaiah (AVHR)':'Dr. Byresh Appaiah',
    'Dr. Byresh Appaiah (HRBR)':'Dr. Byresh Appaiah',
    'Dr. Deepika Gunawan':'Dr. Deepika Gunawan',
    'Dr. Deepika Gunawant':'Dr. Deepika Gunawan',
    'Dr. Girish Varrier (AVHD)':'Dr. Girish Varrier',
    'Dr. Jairam Nair (AVK)':'Dr. Jairam Nair',
    'Dr. Jairam Nair (AVND)':'Dr. Jairam Nair',
    'Dr. Kalpita Thakre(HRBR)':'Dr. Kalpita Thakre',
    'Dr. Nidhin A M (AVHD)':'Dr. Nidhin A M',
    'Dr. Prathyusha  V(AVHVN)':'Dr. Prathyusha  V',
    'Dr. Prathyusha (AHLL-KP)':'Dr. Prathyusha  V',
    'Dr. Sandhya Ramesh (AVM)':'Dr. Sandhya Ramesh',
    'Dr. Shashidhara Gopalkrishna (AVHD)':'Dr. Shashidhara Gopalkrishna',
    'Dr. Shashidhara Gopalkrishna (HRBR)':'Dr. Shashidhara Gopalkrishna',
    'Dr. Smitha  Jaydev(AVHVN)':'Dr. Smitha  Jaydev',
    'Dr. Srinivasa Pandey (AVM)':'Dr. Srinivasa Pandey',
    'Dr. Srinivasa Pandey (AVND)':'Dr. Srinivasa Pandey',
    'Dr. Srinivasa Pandey-AVND':'Dr. Srinivasa Pandey',
    'Dr. Sunil Arya (AVM)':'Dr. Sunil Arya',
    'Dr. Sushma M (AVHR)':'Dr. Sushma M',
    'Dr. Sushma M (HRBR)':'Dr. Sushma M',
    'Dr. Swathi Bhat (AVCMI)':'Dr. Swathi Bhat',
    'Dr. Swathi Bhatt':'Dr. Swathi Bhat',
    'Dr. Vasantha Lakshmi':'Dr. Vasantha Lakshmi',
    'Dr. Vasantha Lakshmi(HRBR)':'Dr. Vasantha Lakshmi',
    'Dr. Vimarsha S':'Dr. Vimarsha S',
    'Dr. Vimarsha S (SSAVCIO)':'Dr. Vimarsha S',
    'Dr. Zankhana Buch (AVCMI)':'Dr. Zankhana Buch',
    'Dr. Zankhana Buch (AVHD)':'Dr. Zankhana Buch',
    'Dr. Zankhana Buch (AVHR)':'Dr. Zankhana Buch',
    'Dr. Zankhana Buch (HRBR)':'Dr. Zankhana Buch',
    'Dr. Srinivasa Pandey':'Dr. Srinivasa Pandey',
    'Dr Shrinivasa Pandey':'Dr. Srinivasa Pandey',
    'Dr Smitha Jayadev':'Dr. Smitha  Jaydev',
    'Dr Vimarsha S':'Dr. Vimarsha S',
    'Dr Swetha Suvarna':'Dr. Swetha S Suvarna',
}

df_call_final["Primary Physician"] = df_call_final["Primary Physician"].replace(mappings)
print(df_call_final.columns)
df_call_final.rename(columns={
    "time_of_day": 'Time_of_Day',
    'Total_Inbound_Duration': 'total_inbound_duration' }, inplace=True)  # Renames 'Total_Inbound_Duration' to 'total_inbound_duration'

# The 'inplace=True' ensures the changes are applied directly to df_call_final

df_call_final.loc[:,'Primary Disease']=df_call_final["Primary Disease Specialty"].replace(
    {'Piles':'Ayurveda Parasurgery'}
)

df_call_final.loc[:,"Time_of_Day"]=df_call_final["Time_of_Day"].replace({
    "Late Night":"Evening","Night":"Evening"})

bins = [0, 60, 300, 600, 1200, 2400]
labels = ['0-1 min', '1-5 min', '5-10 min', '10-20 min', '20-40 min']

# Create a new column with bucketed values
df_call_final['Total_Inbound_Duration'] = pd.cut(df_call_final['total_inbound_duration'], bins=bins, labels=labels, right=True, include_lowest=True)
df_call_final['Total_Outbound_Duration'] = pd.cut(df_call_final['total_outbound_duration'], bins=bins, labels=labels, right=True, include_lowest=True)

bins1 = [0, 1, 2, 3, 4, 5, 6]
labels1 = ['0-1 sec', '1-2 sec', '2-3 sec', '3-4 sec', '4-5 sec', '5-6 sec']
df_call_final['avg_outbound_duration'].fillna(0, inplace=True)
df_call_final['avg_outbound_duration'].fillna(0, inplace=True)

# Create a new column for bucketed durations
df_call_final['Avg_Outbound_Duration'] = pd.cut(df_call_final['avg_outbound_duration'], bins=bins1, labels=labels1, right=True, include_lowest=True)
df_call_final['Avg_Inbound_Duration'] = pd.cut(df_call_final['avg_inbound_duration'], bins=bins1, labels=labels1, right=True, include_lowest=True)

"""df_call_final.loc[:,"Most_Recent_Call_Status"]=df_call_final['Most_Recent_Call_Status'].replace(
    {'Inbound-Completed':'Inbound-Answered',
     "Outbound-Completed":'Outbound-Answered'}
)
"""

# Define custom bins and labels for text length
bins = [0, 50, 150, 300, 1000]  # Define edges of the buckets
labels = ['Very Short', 'Short', 'Medium', 'Long']

# Create a new column for bucketed ranges
df_call_final['Text_length'] = pd.cut(
        df_call_final[ 'Text Length'],
        bins=bins,
        labels=labels,
        right=False,  # Make the intervals left-inclusive
    )

bins = [0, 7, 30, 90, 180, 365]  # Define the edges of the buckets
labels = ['0-7 days', '8-30 days', '31-90 days', '91-180 days', '181-365 days']

# Create a new column for bucketed ranges
df_call_final['days_since_last_call'] = pd.cut(
        df_call_final['days_since_last_call'],
        bins=bins,
        labels=labels,
        right=False,  # Make the intervals left-inclusive
    )

# Define bins and labels for missed_call_ratio
missed_bins = [0, 0.1, 0.3, 0.6, 1]  # Custom bins (adjust as needed)
missed_labels = ['Very Low', 'Low', 'Moderate', 'High']
df_call_final['missed_call_ratio'] = pd.cut(
       df_call_final['missed_call_ratio'],
        bins=missed_bins,
        labels=missed_labels,
        right=False
    )
# Define bins and labels for effective_call_rate
effective_bins = [0, 0.5, 0.7, 0.9, 1]  # Custom bins (adjust as needed)
effective_labels = ['Very Low', 'Low', 'Moderate', 'High']
df_call_final['effective_call_rate'] = pd.cut(
        df_call_final['effective_call_rate'],
        bins=effective_bins,
        labels=effective_labels,
        right=False
    )

# file_paths = [
#     "C:\\Users\\ADMIN\\Downloads\\Lead Conversion (3)\\Lead Conversion\\LeadSquared Data\\LeadSquared1.csv",
#     "C:\\Users\\ADMIN\\Downloads\\Lead Conversion (3)\\Lead Conversion\\LeadSquared Data\\LeadSquared2.csv",
#     "C:\\Users\\ADMIN\\Downloads\\Lead Conversion (3)\\Lead Conversion\\LeadSquared Data\\LeadSquared3.csv",
#     "C:\\Users\\ADMIN\\Downloads\\Lead Conversion (3)\\Lead Conversion\\LeadSquared Data\\LeadSquared4.csv",
#     "C:\\Users\\ADMIN\\Downloads\\Lead Conversion (3)\\Lead Conversion\\LeadSquared Data\\LeadSquared5.csv"
# ]


file_paths = [
    "https://ayurvaidleadscoringmodel.s3.ap-south-1.amazonaws.com/version2/LeadSquared+Data/LeadSquared1.csv",
    "https://ayurvaidleadscoringmodel.s3.ap-south-1.amazonaws.com/version2/LeadSquared+Data/LeadSquared2.csv",
    "https://ayurvaidleadscoringmodel.s3.ap-south-1.amazonaws.com/version2/LeadSquared+Data/LeadSquared3.csv",
    "https://ayurvaidleadscoringmodel.s3.ap-south-1.amazonaws.com/version2/LeadSquared+Data/LeadSquared4.csv",
    "https://ayurvaidleadscoringmodel.s3.ap-south-1.amazonaws.com/version2/LeadSquared+Data/LeadSquared5.csv"]

encodings = ["UTF-8-SIG", "Windows-1252", "Windows-1252", "UTF-8-SIG","UTF-8-SIG"]
dataframes = [
    pd.read_csv(path, encoding=encoding, dtype={"ColumnName": "str"}, low_memory=False)
    for path, encoding in zip(file_paths, encodings)]

#reea the data
raw_data = data_read(file_paths, encodings)

df, metadata = clean_leadsquared_data(raw_data)


def calculate_lead_status(df):
    """
    Calculate metrics for lead statuses.
    """
    total_leads = df.shape[0]
    possible_statuses = ["General Enquiry", "Duplicate", "Unqualified",'RNR']
    counts = {status: df[df["Lead Status"] == status].shape[0] for status in possible_statuses}

    filtered_df = df[~df["Lead Status"].isin(possible_statuses)]
    good_leads = filtered_df.shape[0]

    app_fixed = filtered_df[filtered_df["Appointment Fixed?"] == "Yes"].shape[0]
    won_leads = filtered_df[filtered_df["Lead Status"] == "Won"].shape[0]
    lost_leads = filtered_df[filtered_df["Lead Status"] == "Lost"].shape[0]
    after_gen = total_leads - counts["General Enquiry"]
    after_duplicates = after_gen - counts["Duplicate"]
    after_un = after_duplicates - counts["Unqualified"]
    after_rnr=after_un-counts['RNR']
    # Return all metrics
    return {
        "total_leads": total_leads,
        "general_enquiry": counts["General Enquiry"],
        "duplicate": counts["Duplicate"],
        "unqualified_leads": counts["Unqualified"],
        "RNR":counts["RNR"],
        "good_leads": good_leads,
        "app_fixed": app_fixed,
        "won_leads": won_leads,
        "after_gen": after_gen,
        "after_duplicates": after_duplicates,
        "after_un": after_un,
        'after_rnr':after_rnr,
        'Lost Leads':lost_leads
    }

def prepare_data(metrics):
    data = [
        {
            "Sl No.": 1,
            "Lead Status": "Total Leads",
            "Num of Leads Excluded": "----",
            "Num of Leads Qualified": format(metrics["total_leads"], ",d"),
            "Conversion Rate (%)": "---",
            "Remarks": "The leads generated initially including General Enquiry, Duplicates, Unqualified, RNR, WIP, Appointment Fixed, Won, Lost",
        },
        {
            "Sl No.": 2,
            "Lead Status": "General Enquiry",
            "Num of Leads Excluded": format(metrics["general_enquiry"], ",d"),
            "Num of Leads Qualified": format(metrics["after_gen"], ",d"),
            "Conversion Rate (%)": "-----",
            "Remarks": "General Enquiry are the leads that are usually Job Enquiry, Marketing",
        },
        {
            "Sl No.": 3,
            "Lead Status": "Duplicate",
            "Num of Leads Excluded": format(metrics["duplicate"], ",d"),
            "Num of Leads Qualified": format(metrics["after_duplicates"], ",d"),
            "Conversion Rate (%)": "-----",
            "Remarks": "Duplicate leads which are created as duplicates in Lead Squared.",
        },
        {
            "Sl No.": 4,
            "Lead Status": "Unqualified Leads",
            "Num of Leads Excluded": format(metrics["unqualified_leads"], ",d"),
            "Num of Leads Qualified": format(metrics["after_un"], ",d"),
            "Conversion Rate (%)": "-----",
            "Remarks": "• Unqualified since contact not yet made by CRM team   • Qualified Leads are called as 'Good Leads'",
        },
         {
            "Sl No.": 5,
            "Lead Status": "RNR Leads",
            "Num of Leads Excluded": format(metrics["RNR"], ",d"),
            "Num of Leads Qualified": format(metrics["after_rnr"], ",d"),
            "Conversion Rate (%)": "-----",
            "Remarks": "• RNR is not a part of Good Leads",
        },
        {
            "Sl No.": 6,
            "Lead Status": "Appointment Fixed",
            "Num of Leads Excluded": "----",
            "Num of Leads Qualified": format(metrics["app_fixed"], ",d"),
            "Conversion Rate (%)": round(metrics["app_fixed"]/metrics["after_rnr"],0),
            "Remarks": f"Total num of leads for which appointments were fixed, computed as sum of Appointment Fixed and Won by Lead Status = "
                       f"{metrics['app_fixed']} (Appointment Fixed). • Conversion Rate = (Appointment Fixed / Good Leads) * 100",
        },
        {
            "Sl No.": 7,
            "Lead Status": "Won",
            "Num of Leads Excluded": "----",
            "Num of Leads Qualified": format(metrics["won_leads"], ",d"),
            "Conversion Rate (%)":  round(metrics["won_leads"]/metrics["after_un"],0),
            "Remarks": "Won- Leads show-up for Consultation. • Conversion Rate = (Won / Good Leads) * 100",
        },
    ]
    return data
metrics = calculate_lead_status(df)

# Prepare table
table = dash_table.DataTable(
    columns=[
        {"name": "Sl No.", "id": "Sl No."},
        {"name": "Lead Status", "id": "Lead Status"},
        {"name": "Num of Leads Excluded", "id": "Num of Leads Excluded"},
        {"name": "Num of Leads Qualified", "id": "Num of Leads Qualified"},
        {"name": "Conversion Rate(%)", "id": "Conversion Rate (%)"},
        {"name": "Remarks", "id": "Remarks"},
    ],
    data=prepare_data(metrics),  # Pass the prepared data
    style_table={"width": "100%", "margin": "0 auto", "overflowX": "auto"},
    style_cell={
        "whiteSpace": "normal",
        "height": "auto",
        "textAlign": "right",
    },
    style_header={
        "backgroundColor": "white",
        "fontWeight": "bold",
        "textAlign": "center",
    },
    style_data_conditional=[
        {
            "if": {"row_index": "odd"},
            "backgroundColor": "#f9f9f9",
        },
    ],
    style_cell_conditional=[
        {"if": {"column_id": "Sl No."}, "width": "5%"},
        {"if": {"column_id": "Lead Status"}, "width": "10%"},
        {"if": {"column_id": "Num of Leads Excluded"}, "width": "10%"},
        {"if": {"column_id": "Num of Leads Qualified"}, "width": "10%"},
        {"if": {"column_id": "Conversion Rate(%)"}, "width": "5%", "textAlign": "right"},
        {"if": {"column_id": "Remarks"}, "width": "50%"},
    ],
)

def lead_waterfall_from_table(table_data,metrics):
    """
    Create a Waterfall chart using values from the table.
    """
    try:
        if not table_data or not isinstance(table_data, list):
            raise ValueError("Invalid table_data format. Expected a non-empty list of dictionaries.")
        categories = ["Total Leads", "General Enquiry", "Duplicate", "Unqualified", "Good Leads","Appointment Fixed","Won Leads","Lost Leads"]
        values = [
            int(table_data[0]["Num of Leads Qualified"].replace(",", "")),  # Total Leads
            -int(table_data[1]["Num of Leads Excluded"].replace(",", "")),  # General Enquiry
            -int(table_data[2]["Num of Leads Excluded"].replace(",", "")),  # Duplicate
            -int(table_data[3]["Num of Leads Excluded"].replace(",", "")),  # Unqualified
            metrics["good_leads"],
            -metrics['app_fixed'],
            -metrics['won_leads'],  # Good Leads
            -metrics["Lost Leads"]
        ]

        measure = ["absolute", "relative", "relative", "relative", "absolute","relative", "relative","relative" ]

        fig = go.Figure(go.Waterfall(
            x=categories,
            y=values,
            measure=measure,
            text=[f"{val:,}" for val in values],
            textposition="outside",
            connector={"line": {"color": "rgb(63, 63, 63)"}},
            decreasing={"marker_color": "red"},
            increasing={"marker_color": "green"},
            totals={"marker_color": "blue"}
        ))
        fig.update_layout(
            title_x=0.5,
            height=600,
            width=1500,
            template="plotly_white",
            yaxis=dict(title="Number of Leads"),
            xaxis=dict(title="Categories"),
            waterfallgap=0.3,
        )

        return fig

    except Exception as e:
        print("Error in lead_waterfall_from_table:", e)
        return go.Figure().update_layout(title="Error in Waterfall Chart")

"""####################################   Conversion Funnnel  ###################################"""

def create_card(title, value, color, card_id):
    """
    Creates a card component dynamically.

    Args:
        title (str): The title of the card.
        value (str): The value to display in the card.
        color (str): The color of the card.
        card_id (str): The ID of the card for dynamic updates.

    Returns:
        dbc.Card: A Dash Bootstrap card component.
    """
    return dbc.Card(
        dbc.CardBody(
            [
                html.H5(title, className="card-title"),
                html.H2(value, className="card-text", id=card_id),
            ]
        ),
        color=color,
        inverse=True
    )
cards = [
    create_card("Total Leads", format(metrics["total_leads"], ",d"), "#3333CC", "total-leads"),
    create_card("Good Leads", format(metrics["good_leads"], ",d"), "primary", "good-leads"),
    create_card("Appointment Fixed", format(metrics["app_fixed"], ",d"), "#008080", "appointment-fixed"),
    create_card("Won", format(metrics["won_leads"], ",d"), "#85AADF", "took-consultation")]

row_1 = dbc.Row(
    [dbc.Col(card, width=3) for card in cards],
    className="mb-4",
)

# Extract excluded sources and date range
excluded_sources = metadata["excluded_sources"]
excluded_sources_text = ", ".join(excluded_sources)
min_date, max_date = metadata["date_range"]

text_under_cards = html.Div(
    [
        html.P("Data Source: LeadSquared and Exotel,TataSmartflow"),
        html.P(f"Timeline: {min_date} to {max_date}",style={"font-weight": "bold"}),  # Dynamically generated date range
        html.P(f"Total Leads: Leads excluding Lead Sources {excluded_sources_text} "
               "and TEST leads (Including Null Lead Status)."),
        html.P("Good Leads: Leads excluding General Enquiry, Duplicate,and Unqualified."),
    ],
    style={"padding": "20px", "background-color": "#CCCCFF", "border-radius": "5px"}
)

''' Call back fucntion defined for the lead status'''
@app.callback(
    [
        Output("total-leads", "children"),
        Output("good-leads", "children"),
        Output("appointment-fixed", "children"),
        Output("took-consultation", "children"),
        Output("total-inbound-calls", "children"),
        Output('total-outbound-calls',"children"),
        Output('total-unqiue-calls',"children"),
        Output('app-calls','children'),
        Output('won-calls','children'),
        Output("lead-waterfall-graph", "figure"),
        Output("table", "data"),
    ],
    Input("dummy-input", "value")
)
def update_dashboard(_):
    metrics = calculate_lead_status(df)
    table_data = prepare_data(metrics)
    waterfall_chart = lead_waterfall_from_table(table_data,metrics)
    total_leads = format(metrics["total_leads"], ",d")
    good_leads = format(metrics["good_leads"], ",d")
    app_fixed = format(metrics["app_fixed"], ",d")
    won_leads = format(metrics["won_leads"], ",d")

    return total_leads, good_leads, app_fixed, won_leads, waterfall_chart, table_data
table_data = prepare_data(metrics)

carousel = dbc.Carousel(
    items=[
        {
            "key": "1",
            "src": "",  # Leave this empty to load the plot
            "header": "Lead Status Waterfall",
            "content": html.Div(
                dcc.Graph(figure=lead_waterfall_from_table(prepare_data(metrics),metrics), config={'displayModeBar': False}),
                style={"height": "100%", "width": "50%"}
            )
        },
        {
            "key": "2",
            "header": "Transition Diagram",
            "caption": "This shows the transition of leads.",
             "content": html.Div([
    dbc.Container([
        dbc.Row([
            dbc.Col(html.H2("Lead Status Transition Diagram", className="text-center mt-4 mb-4"), width=12)
        ]),
        dbc.Row([
            dbc.Col(
                html.Div(
                    html.Img(
                        src="/assets/image.jpg",  # Make sure this path is correct
                style={"width": "100%", "max-width": "500px", "height": "500px"}
                    ),
                    style={"border": "1px solid #ccc", "padding": "10px"}  # Optional styling for the div
                ),
                width=12
            )
        ])
    ])
])},
        {
            "key": "3",
            "header": "Table Data Summary",
            "content": html.Div(
                table,
                style={"height": "300%", "width": "300%", "padding": "20px"}
            )
        },
    ],
    className="carousel-fade",)



@app.callback(
    Output('carousel-content', 'children'),
    Input('carousel-options', 'value')
)
def update_carousel_content(selected_option):
    if selected_option == 'transition-diagram':
        return  html.Div([
    dbc.Container([
        dbc.Row([
            dbc.Col(html.H2("Lead Status Transistion Diagram", className="text-center mt-4 mb-4"), width=12)
        ]),
        dbc.Row([
            dbc.Col(
                html.Div(
                    html.Img(
                        src="https://ayurvaidleadscoringmodel.s3.ap-south-1.amazonaws.com/version2/assets/image.jpg",  # Make sure this path is correct
                style={"width": "100%", "max-width": "500px", "height": "500px"}
                    ),
                    style={"border": "1px solid #ccc", "padding": "10px"}  # Optional styling for the div
                ),
                width=12
            )
        ])
    ])
])
    elif selected_option == 'lead-waterfall':
        return dcc.Graph(figure=lead_waterfall_from_table(prepare_data(metrics),metrics), config={'displayModeBar': False})

    elif selected_option=="data-summary":\
        return html.Div(
                table,  # Ensure the table is correctly included here
                style={"height": "100%", "width": "100%", "padding": "20px"}
            )

    return None

@app.callback(
    Output("carousel", "active_index"),
    Input("slide-number", "value"),
)
def select_slide(idx):
    return idx

def conversion_funnel(df):
    # Filter for "Good Leads" by excluding unwanted statuses
    filtered_df = df[~df["Lead Status"].isin(["General Enquiry", "Unqualified", "Duplicate"])]
    good_leads_count = len(filtered_df)

    # Count appointment fixed and won leads
    appointment_fixed_count = len(filtered_df[filtered_df["Appointment Fixed?"] == "Yes"])
    won_leads_count = len(filtered_df[filtered_df["Lead Status"] == "Won"])

    # Calculate conversion rates
    conversion_rate_to_appointment_fixed = round((
        (appointment_fixed_count / good_leads_count) * 100 if good_leads_count > 0 else 0
    ),0)
    conversion_rate_to_won = round((
        (won_leads_count / good_leads_count) * 100 if good_leads_count > 0 else 0
    ),0)


    funnel_figure = go.Figure(go.Funnel(
        y=[
            #f"Total Leads ({total_leads:,})",
            f"Good Leads ({good_leads_count:,})",
            f"Appointment Fixed ({appointment_fixed_count:,})",
            f"Won ({won_leads_count:,})"
        ],
        x=[good_leads_count, appointment_fixed_count, won_leads_count],
        textposition="inside",
        connector={"line": {"color": "black"}}
    ))

    # # Annotate conversion rates on the chart
    # funnel_figure.add_annotation(
    #     x=3.5,
    #     y=2,
    #     text=f"{conversion_rate_to_appointment_fixed}%</b>",
    #     font=dict(size=14),
    #     showarrow=False
    # )
    # funnel_figure.add_annotation(
    #     x=4.1,
    #     y=3,
    #     text=f"{conversion_rate_to_won:}%</b>",
    #     font=dict(size=14),
    #     showarrow=False
    # )
    funnel_figure.update_layout(title_x=0.5,template="plotly_white",height=500,width=1000)
    return funnel_figure

@app.callback(
    Output('conversion-funnel-graph1', 'figure'),
    [Input('date-range', 'start_date'),Input('date-range', 'end_date'),Input('year-dropdown','value')])
def update_conversion_funnel(start_date, end_date, selected_years):
    filtered_df = df[(df['Modified On'] >= start_date) & (df['Modified On'] <= end_date)]
    if selected_years:
        filtered_df = filtered_df[filtered_df['Modified On'].dt.year.isin(selected_years)]
    funnel_figure = conversion_funnel(filtered_df)

    return funnel_figure

# Sidebar style
SIDEBAR_STYLE = {
    "position": "fixed",
    "top": 0,
    "left": 0,
    "bottom": 0,
    "width": "11rem",
    "padding": "2rem 1rem",
    "background-color": "#f8f9fa",
    "transition": "all 0.5s"  # Smooth transition for opening/closing
}

# Main content style
CONTENT_STYLE = {
    "margin-left": "14rem",
    "margin-right": "2rem",
    "padding": "2rem 1rem",
    "transition": "margin-left 0.5s"  # Smooth transition for content
}

CONTENT_STYLE_COLLAPSED = {
    "margin-left": "2rem",  # Reduced margin when sidebar is closed
    "margin-right": "2rem",
    "padding": "2rem 1rem",
    "transition": "margin-left 0.5s"  # Smooth transition for content
}

header = dbc.Row(
    [
        dbc.Col(html.Img(src="https://i.ibb.co/wJknJPG/images-removebg-preview.png", style={"width": "120px", "height": "120px"}), width="auto"),
        dbc.Col(html.H1("Dashboard", className="display-5", style={"textAlign": "left", "font-size": "28px",'color':'blue', 'font-family': 'Times New Roman',"font-weight": "bold"}), width=False),
    ],
    align="center",
    style={"padding": "10px 0"}
)

# Sidebar layout with the logo added
sidebar = html.Div(
    [
        header,
        html.Hr(),
        dbc.Nav(
            [
                dbc.NavLink("Data Summary", href="/", active="exact"),
                dbc.NavLink("EDA", href="/eda", active="exact"),
                dbc.NavLink("Modeling", href="/data-preprocessing", active="exact"),  # Added Modeling page link
                #dbc.NavLink("Make Predictions" ,href="/make-predictions", active="exact")
            ],
            vertical=True,
            pills=True,
        ),
    ],
    style=SIDEBAR_STYLE,
    id='sidebar'  # ID to control sidebar visibility
)

# Content layout
content = html.Div(id="page-content", style=CONTENT_STYLE)

# App layout with a toggle button for the sidebar
app.layout = html.Div([
    dcc.Store(id='side_click', data='SHOW'),  # Initialize store with 'SHOW'
    dbc.Button("Toggle Sidebar", outline=True, color="secondary", className="mr-1", id="btn_sidebar"),
    dcc.Location(id="url"),
    sidebar,content,],#style={'font-family': 'Cambria'}
)

# Callback to toggle the sidebar visibility using dcc.Store
@app.callback(
    [Output("sidebar", "style"),
     Output("page-content", "style"),
     Output("side_click", "data")],  # Update the sidebar and content style, and the store
    [Input("btn_sidebar", "n_clicks")],
    [State("side_click", "data")]
)
def toggle_sidebar(n_clicks, side_click):
    if n_clicks is None:
        # If button has not been clicked yet, keep the initial state
        return SIDEBAR_STYLE, CONTENT_STYLE, side_click

    # Toggle the state of the sidebar based on current state
    if side_click == "SHOW":
        sidebar_style = {"display": "none"}  # Hide the sidebar
        content_style = CONTENT_STYLE_COLLAPSED
        cur_side_click = "HIDDEN"
    else:
        sidebar_style = SIDEBAR_STYLE
        content_style = CONTENT_STYLE
        cur_side_click = "SHOW"

    return sidebar_style, content_style, cur_side_click

columns_call=['Gender', 'Primary Physician',  'Insured', 'Program Offering', 'Severity', 'Primary Disease Specialty','num_missed_inbound_calls','num_missed_outbound_calls',
       'First Call Closure', 'Primary Disease', 'Chronicity','NFT Qualification', 'Spot', 'Time_of_Day','Status','Direction',
       'Total_Inbound_Duration', 'Total_Outbound_Duration','num_inbound_calls', 'num_outbound_calls', 'Text_length',
       'utm_source_Campaign Source',   'days_since_last_call', 'Age Group', 'Lead Source_Renamed']

viz1 = call_Visualisation(df_call_final)

df_prediction = pd.read_excel('https://ayurvaidleadscoringmodel.s3.ap-south-1.amazonaws.com/version2/LeadSquared+Data/test_lead_predictions_full.xlsx')
df_prediction.loc[:,"Prediction"]=df_prediction["Prediction"].replace({
    1:"Yes",0:"No"
})

bins = [0, 60, 300, 600, 1200, 2400]
labels = ['0-1 min', '1-5 min', '5-10 min', '10-20 min', '20-40 min']

# Create a new column with bucketed values

df_prediction['total_inbound_duration'] = pd.cut(df_prediction['total_inbound_duration'], bins=bins, labels=labels, right=True, include_lowest=True)
df_prediction['total_outbound_duration'] = pd.cut(df_prediction['total_outbound_duration'], bins=bins, labels=labels, right=True, include_lowest=True)
df_prediction['avg_inbound_duration'] = pd.cut(df_prediction['avg_inbound_duration'], bins=bins, labels=labels, right=True, include_lowest=True)
df_prediction['avg_outbound_duration'] = pd.cut(df_prediction['avg_outbound_duration'], bins=bins, labels=labels, right=True, include_lowest=True)
bins = [0, 50, 150, 300, 1000] 
labels = ['Very Short', 'Short', 'Medium', 'Long']
df_prediction['Text Length'] = pd.cut(df_prediction[ 'Text Length'], bins=bins,labels=labels,right=False )


bins = [0, 7, 30, 90, 180, 365]  # Define the edges of the buckets
labels = ['0-7 days', '8-30 days', '31-90 days', '91-180 days', '181-365 days']
df_prediction['days_since_last_call'] = pd.cut(df_prediction['days_since_last_call'],
        bins=bins,
        labels=labels,
        right=False,  # Make the intervals left-inclusive
    )



columns_opp=['Gender', 'Primary Physician',  'Insured', 'Program Offering', 'Primary Disease Specialty', 'Primary Disease',
        'Chronicity','NFT Qualification', 'Spot', 'time_of_day','total_inbound_duration', 'total_outbound_duration','num_inbound_calls',
        'num_outbound_calls', 'Text Length','days_since_last_call','utm_source_Campaign Source', 
         'Age Group', 'Lead Source_Renamed']#'avg_inbound_duration', 'avg_outbound_duration',

df_prediction['num_inbound_calls'] = df_prediction['num_inbound_calls'].sort_values(ascending=True).values
df_prediction['num_outbound_calls'] = df_prediction['num_outbound_calls'].sort_values(ascending=True).values

viz2=PredictedBivariateAnalysis(df_prediction)

# Callback to update bivariate analysis
@app.callback(
    [Output('cross-table-bivariate', 'data'),
     Output('cross-table-bivariate', 'columns'),
     Output('multivariate-analysis', 'figure')],
    [Input('primary-variable-dropdown', 'value'),
     Input('status-radio', 'value')]
)

def update_call_bivariate_output(primary_variable, selected_status):
    if primary_variable and selected_status:
        # Use the correct cross-table function and method from the Visualisation class
        if selected_status == "Modeling Data":
            cross_table = generate_cross_table_call_app(df_call_final, primary_variable)
            fig = viz1.bivariate_call_app_analysis([primary_variable])  # Corrected method call

        elif selected_status == "Predicted Closed":
            cross_table = generate_cross_table_closed(df_prediction, primary_variable)
            fig = viz2. bivariate_closed_opportunity_analysis_predicted([primary_variable])  # Corrected method call

        else:  # WIP Status
            cross_table = generate_cross_table_wip(df_prediction, primary_variable)
            fig = bivariate_wip_predicted(df_prediction, [primary_variable])  # Pass df and variable

        # Prepare the data and columns for the table
        table_data = cross_table.to_dict('records')
        table_columns = [{"name": i, "id": i} for i in cross_table.columns]

        return table_data, table_columns, fig

    return [], [], {}


########Missing Values plot############################
def plot_missing(df):
    # df=df.drop(["Prospect Id","Lead Name","Opportunity ID"],axis=1)
    ignored_status=["General Enquiry","Unqualified","Duplicate",'RNR','WIP']
    df=df[~df["Lead Status"].isin(ignored_status)]
    missing_values = df.isnull().sum()
    total_entries = len(df)
    missing_percentage = round((missing_values / total_entries) * 100, 0)
    missing_df1 = pd.DataFrame({'Column': missing_percentage.index, 'Percentage': missing_percentage.values})
    fig = px.bar(missing_df1[:30], x='Column', y='Percentage', title='Percentage of missing values in each column',color='Column',
                 labels={'Percentage': 'Percentage of missing values(%)', 'Column': 'Columns'},
                 text='Percentage')
    fig.update_layout(
        width=1400,
        height=600,
        title_x=0.5,template="plotly_white",
        yaxis=dict(title="Percentage of missing values(%)", ticksuffix="%"),
        xaxis=dict(title="Columns", categoryorder='total descending')
    )
    fig.update_traces(texttemplate='%{text}%', textposition='outside')
    return fig


@app.callback(
    Output('primary-variable-dropdown', 'options'),
    [Input('status-radio', 'value')]
)
def update_dropdown_options(selected_status):
    """
    Dynamically update the dropdown options based on the selected status.
    """
    if selected_status == "Modeling Data":
        return [{'label': col, 'value': col} for col in columns_call]
    elif selected_status in ["Predicted Closed", "Predicted WIP"]:
        return [{'label': col, 'value': col} for col in columns_opp]
    return []

@app.callback(
    Output('timeline-display', 'children'),
    [Input('status-radio', 'value')]
)
def update_timeline_display(selected_status):
    """
    Dynamically update the timeline text based on the selected status.
    """
    if selected_status == "Modeling Data":
        return "*Timeline:* 1st April 2023 till 29th September 2024"
    elif selected_status in ["Predicted Closed", "Predicted WIP"]:
        return "*Timeline:* October 2024 till 12th December 2024"
    return "*Timeline:* Not available"

@app.callback(
    Output("page-content", "children"),
    [Input("url", "pathname")]
)
def render_page_content(pathname):
    if pathname == "/":
        return html.Div([
            row_1,  # Cards Row
            text_under_cards,
             html.Br(), # Text Under Cards
            html.Div([
                dcc.RadioItems(
                    id='carousel-options',
                    options=[

                        {'label':"Transition Diagram",'value':'transistion-diagram'},
                        {'label': 'Lead Status Waterfall', 'value': 'lead-waterfall'},
                        {'label':"Table : Data Summary",'value':'data-summary'}
                    ],
                    value='transition-diagram',
                    labelStyle={'display': 'inline-block', 'margin-right': '20px'}
                ),    dcc.Loading(
        id="loading-carousel",
        type="default",
        children=html.Div(id='carousel-content')
    ),

                html.Div(id='carousel-content')
            ]),
            html.H1("Conversion Funnel", className="text-primary"),
            html.Div([
                dcc.DatePickerRange(
                    id='date-range',
                    min_date_allowed=df['Modified On'].min(),
                    max_date_allowed = datetime.now() ,
                    start_date=df['Modified On'].min(),
                    end_date = datetime.now(),
                ),
                dcc.Dropdown(
                    id='year-dropdown',
                    options=[{'label': year, 'value': year} for year in sorted(df['Modified On'].dt.year.dropna().unique())],
                    multi=True,
                    placeholder="Filter by Year"
                ),
                    ], style={'width': '30%', 'display': 'inline-block'}),dcc.Loading(
            id="loading-funnel",
            type="default",
            children=dcc.Graph(id='conversion-funnel-graph1')
        ),

        ])
    elif pathname == "/eda":
        return html.Div([
            dcc.Tabs(id="eda-tabs", value='missing-analysis', children=[
                dcc.Tab(label='Missing Values Analysis', value='missing-analysis'),
                dcc.Tab(label='Bivariate Charts', value='bivariate-tab'),
            ]),
            html.Div(id="eda-output", style={"margin-top": "20px"})
        ])
    elif pathname == "/data-preprocessing":
        return html.Div([
            dcc.Tabs(id="data-preprocessing-tabs", value='preprocessing', children=[
                dcc.Tab(label='Data Cleaning', value='preprocessing'),
                #dcc.Tab(label='Feature Engineering', value='feature-engineering'),
                dcc.Tab(label='Significant Variables', value='feature-selection'),
                dcc.Tab(label='Model Performance', value='model-performance'),
                dcc.Tab(label='Confusion Matrix', value='confusion-matrix'),
                dcc.Tab(label='Model lift Chart', value='model-liftchart'),
                dcc.Tab(label='Shap Values of models', value='model-shap'),
                dcc.Tab(label='Optimal Threshold', value='optimal-threshold')
            ]),
            html.Div(id="data-preprocessing-output", style={"margin-top": "20px"})
        ])
    elif pathname == "/make-predictions":  # Content for the Modeling page
        return html.Div([
            dcc.Tabs(id="make-predictions", value='tab-1', children=[
                dcc.Tab(label='Logistic Regression', value='tab-1'),
            ]),
            html.Div(id='modeling-tabs-content')
        ])
    return html.Div([
        html.H1("404: Not found", className="text-danger"),
        html.Hr(),
        html.P(f"The pathname {pathname} was not recognised..."),
    ])
#lback for handling tabs in the EDA section
@callback(
    Output('eda-output', 'children'),
    [Input('eda-tabs', 'value')]
)
def display_eda_content(selected_tab):

    if selected_tab == 'missing-analysis':
        figure = plot_missing(df)
        return dcc.Graph(figure=figure)

    elif selected_tab == 'bivariate-tab':
        return html.Div(
    [
        dcc.RadioItems(
            id='status-radio',
            options=[
                {'label': 'Modeling Data', 'value': 'Modeling Data'},
                {'label': 'Predicted Closed', 'value': 'Predicted Closed'},
                 {'label': 'Predicted WIP', 'value': 'Predicted WIP'}
            ],
            value='Modeling Data',
            labelStyle={'display': 'inline-block', 'margin-right': '20px'},
            style={'color': 'black', 'font-size': 23, 'margin-bottom': '28px'}
        ),
        dcc.Markdown(id='timeline-display',style={'font-size':'18px','margin-bottom':'20px'}),
        dcc.Graph(id='multivariate-analysis'),
        dcc.Dropdown(id='primary-variable-dropdown',value='Gender', placeholder="Select a variable", style={'color': 'black', 'font-size': 15,'width':'30%',},
          maxHeight=100, className='customDropdown'),
        #dcc.Dropdown(columns, placeholder="Select secondary variables", style={'color': 'black', 'font-size': 20}, id='secondary-variable-dropdown', multi=True, maxHeight=100, className='customDropdown'),
        dash_table.DataTable(id='cross-table-bivariate',
                             style_header={'backgroundColor': 'white', 'color': 'black'},
                             style_cell={'backgroundColor': 'white', 'color': 'black'},
                             style_table={'overflowX': 'auto'}),

    ]
)

    return html.Div()
@app.callback(
    Output('data-preprocessing-output', 'children'),
    [Input('data-preprocessing-tabs', 'value')]
)
def display_data_preparation_content(selected_tab):
    if selected_tab == 'preprocessing':
        items1 = [
            dbc.DropdownMenuItem("Table Rows", id='table-rows-option'),
            dbc.DropdownMenuItem(divider=True),
            dbc.DropdownMenuItem("Waterfall Chart", id='waterfall-chart-option-1')
        ]

        items2 = [
    dbc.DropdownMenuItem("Table Column", id='table-column-option'),
    dbc.DropdownMenuItem(divider=True),
    dbc.DropdownMenuItem("Waterfall Chart", id='waterfall-chart-option-2'),
    dbc.DropdownMenuItem(divider=True),
    dbc.DropdownMenuItem("Variable Name Table", id='variable-name-table-option'),  # New Item
]


        items3 = [dbc.DropdownMenuItem("Class Distribution", id='class-distribution-option')]

        return html.Div([dbc.Row([
            dbc.Col( dbc.DropdownMenu(items1, label="Data Reduction", color="success", className="m-1"),width=30),
             dbc.Col(html.Div(id='image1-container'), width=12)]),
            dbc.Row([dbc.Col(dbc.DropdownMenu(items2, label="Variable Reduction", color="warning", className="m-1"), width=30),
            dbc.Col(html.Div(id='image2-container'), width=12),
            dbc.Col(html.Div(id='image4-container'), width=12)]),
            dbc.Row([dbc.Col(dbc.DropdownMenu(items3, label="Class Distribution", color="info", className="m-1"), width=30),
            dbc.Col(html.Div(id='image3-container'), width=12)]),], style={"display": "flex", "flexWrap": "wrap", 'width': '80%'})

    elif selected_tab == 'feature-engineering':
        return html.Div([
            html.H4("New Features : Seasons (Lead Created On) and Response (Notes)"),
        ])
    elif selected_tab == 'feature-selection':
        merged_df = pd.read_csv("https://ayurvaidleadscoringmodel.s3.ap-south-1.amazonaws.com/version2/LeadSquared+Data/SignificantVar.csv")
        # merged_df=merged_df.drop(['Unnamed: 0'],axis=1)
        # merged_df = merged_df.rename(columns={"Var Imp(DT)":"Var Imp DT (%)",'Variables':'Feature',
        #                                        'Odds Ratio (LR)':'OR (LR)','P-value (LR)':'P-Values (LR)'})
        # merged_df=merged_df[merged_df["Feature"]!="Appointment Fixed?"]
        # merged_df['P-Values (LR)'] = merged_df['P-Values (LR)'].apply(lambda x: f"{x:.10f}")

        # merged_df['Var Imp DT (%)'] = (
        #     merged_df['Var Imp DT (%)']
        #     .str.replace('%', '', regex=False)  # Remove percentage symbol
        #     .replace('--', np.nan)  # Replace '--' with NaN
        #     .astype(float)  # Convert to float
        # )
        merged_df.rename(columns={"Unnamed:0":"Sl No.","Feature":"Variables"},inplace=True)
        # merged_df.drop( merged_df[ merged_df['Variables'] == 'const'].index, inplace=True)
        # merged_df = merged_df[merged_df['Variables'] != 'const']

        table_columns = [{"name": col, "id": col} for col in merged_df.columns]
        style_data_conditional = [
            {
                'if': {'filter_query': f'{{OR(LR)}} = {merged_df["OR(LR)"].min()}', 'column_id': 'OR(LR)'},
                'backgroundColor': '#FF4136',  # Red for min value
                'color': 'white'
            },
            {
                'if': {'filter_query': f'{{OR(LR)}} = {merged_df["OR(LR)"].max()}', 'column_id': 'OR(LR)'},
                'backgroundColor': '#3D9970',  # Green for max value
                'color': 'white'
            },
            {
                'if': {'filter_query': '{P-value(LR)} <= 0.05', 'column_id': 'P-value(LR)'},
                'backgroundColor': '#FFDC00',  # Yellow for significant p-values
                'color': 'black'
            },
            {
                'if': {'filter_query': '{Coefficient LR} > 0', 'column_id': 'Coefficient LR)'},
                'backgroundColor': '#C8E6C9'  # Light green for positive coefficients
            },
            {
                'if': {'filter_query': '{Coeff(LR)} < 0', 'column_id': 'Coeff(LR)'},
                'backgroundColor': '#FFCDD2'  # Light red for negative coefficients
            },
            {
                'if': {'filter_query': f'{{Var Imp DT(%)}} = {merged_df["Var Imp DT(%)"].max()}',
                    'column_id': "Var Imp DT(%)"},
                'backgroundColor': '#B39DDB',  # Purple for max importance
                'color': 'white'
            },
            {
                'if': {'filter_query': f'{{Cum VarImp DT(%)}} = {merged_df["Cum VarImp DT(%)"].max()}',
                    'column_id': 'Cum VarImp DT(%)'},
                'backgroundColor': '#B39DDB',  # Purple for max importance
                'color': 'white'
            },
             {
                'if': {'filter_query': f'{{U-Test(P-value)}} = {merged_df["U-Test(P-value)"].max()}',
                    'column_id': 'U-Test(P-value)'},
                'backgroundColor': '#B39DDB',  # Purple for max importance
                'color': 'white'
            },
            {
                'if': {'filter_query': f'{{Chi-Square(P-value)}} = {merged_df["Chi-Square(P-value)"].max()}',
                    'column_id': 'Chi-Square(P-value)'},
                'backgroundColor': '#B39DDB',  # Purple for max importance
                'color': 'white'
            },
        ]
        dash_table_component = dash_table.DataTable(
            data=merged_df.to_dict('records'),
            columns=table_columns,
            filter_action='native',  # Enable filtering
            sort_action='native',  # Enable sorting
            style_table={"width": "100%", "margin": "0 auto"},  # Full width without overflow
            style_cell={"padding": "10px", "whiteSpace": "normal", "height": "auto", "minWidth": "100px", "width": "100px", "maxWidth": "200px"},
            style_header={"backgroundColor": "#f1f1f1", "fontWeight": "bold"},
            style_data_conditional=style_data_conditional,
            style_cell_conditional=[
                {"if": {"column_id": "Variables"}, "textAlign": "left"},
                {"if": {"column_id": "OR(LR)"}, "textAlign": "right"},
                {"if": {"column_id": "P-Values(LR)"}, "textAlign": "right"},
                {"if": {"column_id": "Coefficient LR"}, "textAlign": "right"},
                {"if": {"column_id": "Var Imp DT(%)"}, "textAlign": "right"},
                {"if": {"column_id": "Cum VarImp DT(%)"}, "textAlign": "right"},
                {"if": {"column_id": "Chi-Square(P-value)"}, "textAlign": "right"},
                {"if": {"column_id": "U-Test(P-value)"}, "textAlign": "right"},
            ],
        )

 # Embed the external HTML file in an iframe

        return html.Div([
    dash_table_component,
    html.Hr(),  # Separator line
    html.Iframe(
    src="https://ayurvaidleadscoringmodel.s3.ap-south-1.amazonaws.com/version2/assets/feature_importance_plot.html",  # Update this to match the assets folder path
    style={"width": "100%", "height": "600px", "border": "none"}
)])

    elif selected_tab=="model-performance":

       # Define the data for the table
        table_data_per = [
            {"Sl No.": 1, "Metrics": "Accuracy", "Train LR": "82%", "Test LR": "84%",
              "Train DT": "80%", "Test DT": "77%",
                "Train MLP": "85%", "Test MLP": "85%",},
              # "Train LightGBM":"83%","Test LightGBM":"85%"},

            {"Sl No.": 2, "Metrics": "TPR (Sensitivity)", "Train LR": "81%", "Test LR": "82%",
             "Train DT": "94%", "Test DT": "83%",
             "Train MLP": "83%", "Test MLP": "77%",},
             #"Train LightGBM":"92%","Test LightGBM":"76%"},

            {"Sl No.": 3, "Metrics": "TNR (Specificity)", "Train LR": "82%", "Test LR": "87%",
             "Train DT": "74%", "Test DT": "74%",
               "Train MLP": "88%", "Test MLP": "85%",},
            #   "Train LightGBM":"78%","Test LightGBM":"89%"},

            {"Sl No.": 4, "Metrics": "FPR", "Train LR": "26%", "Test LR": "25%",
              "Train DT": "26%", "Test DT": "28%",
              "Train MLP": "14%", "Test MLP": "12%",},
              # "Train LightGBM":"21%","Test LightGBM":"11%"},

            {"Sl No.": 5, "Metrics": "FNR", "Train LR": "18%", "Test LR": "19%",
              "Train DT": "4%", "Test DT": "17%",
              "Train MLP": "16%", "Test MLP": "23%",},
             # "Train LightGBM":"7%","Test LightGBM":"23%"},

            {"Sl No.": 6, "Metrics": "Precision", "Train LR": "69%", "Test LR": "73%",
             "Train DT": "63%", "Test DT": "61%",
             "Train MLP": "73%", "Test MLP": "76%",},
            #  "Train LightGBM":"67%","Test LightGBM":"78%"},

            {"Sl No.": 9, "Metrics": "F1 Score", "Train LR": "74%", "Test LR": "76%",
              "Train DT": "70%", "Test DT": "76%",
              "Train MLP": "77%", "Test MLP": "76%",},
              # "Train LightGBM":"77%","Test LightGBM":"77%"},

            {"Sl No.": 10, "Metrics": "ROC AUC Score", "Train LR": "90%", "Test LR": "91%",
              "Train DT": "94%", "Test DT": "85%",
              "Train MLP": "89%", "Test MLP": "88%",},
              # "Train LightGBM":"93%","Test LightGBM":"92%"},

                {"Sl No.": 11, "Metrics": "K-S Score", "Train LR": "64%", "Test LR": "66%",
              "Train DT": "72%", "Test DT": "57%",
              "Train MLP": "69%", "Test MLP": "67%",},
              # "Train LightGBM":"72%","Test LightGBM":"69%"},
        ]

        # Define the table columns
        table_columns = [
            {"name": "Sl No.", "id": "Sl No."},
            {"name": "Metrics", "id": "Metrics"},
            {"name": "Train LR", "id": "Train LR"},
            {"name": "Test LR", "id": "Test LR"},
            {"name": "Train DT", "id": "Train DT"},
            {"name": "Test DT", "id": "Test DT"},
            {"name": "Train MLP", "id": "Train MLP"},
            {"name": "Test MLP", "id": "Test MLP"},
             #{"name": "Train LightGBM", "id": "Train LightGBM"},
           # {"name": "Test LightGBM", "id": "Test LightGBM"},
        ]

        # Dash DataTable component definition remains the same
        dash_table_component = dash_table.DataTable(
            data=table_data_per,
            columns=table_columns,
            style_table={"width": "90%", "margin": "0 auto", "overflowX": "auto"},
            style_cell={"padding": "10px", "whiteSpace": "normal", "height": "auto"},
            style_header={"backgroundColor": "#f1f1f1", "fontWeight": "bold"},
            style_data_conditional=[
                {"if": {"row_index": "odd"}, "backgroundColor": "#f9f9f9"},
            ],
            style_cell_conditional=[
                {"if": {"column_id": "Sl No."}, "textAlign": "center"},
                {"if": {"column_id": "Metrics"}, "textAlign": "left"},
                {"if": {"column_id": ["Train LR", "Test LR", "Train DT", "Test DT", "Train MLP", "Test MLP","Train LightGBM", "Test LightGBM"]}, "textAlign": "center"},
            ],
        )

        return html.Div(dash_table_component)
    elif selected_tab=="model-liftchart":

        html.H1("Lift Chart Viewer", style={"textAlign": "center"}),

        return html.Div([
                    html.Label("Select Model:", style={"fontSize": "18px"}),
                    dcc.RadioItems(
                        id="model-selection",
                        options=[
                            {"label": "Base Models", "value": "base-models"},
                            {"label": "K-S Chart", "value": "advanced"},],
                        value="base-models",  # Default selection
                        labelStyle={"display": "block", "marginBottom": "10px"},
                    ),
                    html.Hr(),
                    html.Div(id="lift-chart-container"),  # Dynamic lift chart container
                ])
    elif selected_tab == "confusion-matrix":
                # Confusion matrix tab content
               return html.Div([
    html.H1("Confusion Matrix Viewer", style={"textAlign": "center", "marginBottom": "20px"}),

    # Radio Buttons for Model Selection
    html.Div([
        html.Label("Select Model:", style={"fontSize": "18px", "marginRight": "10px"}),
        dcc.RadioItems(
            id="model-selection-confusion",
            options=[
                {"label": "Logistic Regression", "value": "logistic_regression"},
                {"label": "Decision Tree", "value": "decision_tree"},
                {"label": "MLP", "value": "mlp"}
            ],
            value="logistic_regression",
            labelStyle={"display": "inline-block", "marginRight": "20px"}
        )
    ], style={"textAlign": "center", "marginBottom": "30px"}),

    # Model Details Section
    html.Div(id="model-details", style={
        "textAlign": "center",
        "fontSize": "16px",
        "marginBottom": "30px",
        "padding": "10px",
        "border": "1px solid #ddd"
    }),

    # Confusion Matrix Layout with Larger Images
    html.Div([
        # Train Confusion Matrix
        html.Div([
            html.H4("Train Confusion Matrix", style={"textAlign": "center", "marginBottom": "10px"}),
            html.Img(id="train-number", style={
                "width": "90%", "height": "auto", "margin": "10px", "display": "block"
            }),
            html.Img(id="train-percentage", style={
                "width": "90%", "height": "auto", "margin": "10px", "display": "block"
            })
        ], style={"display": "inline-block", "width": "32%", "textAlign": "center"}),

        # Test Confusion Matrix
        html.Div([
            html.H4("Test Confusion Matrix", style={"textAlign": "center", "marginBottom": "10px"}),
            html.Img(id="test-number", style={
                "width": "90%", "height": "auto", "margin": "10px", "display": "block"
            }),
            html.Img(id="test-percentage", style={
                "width": "90%", "height": "auto", "margin": "10px", "display": "block"
            })
        ], style={"display": "inline-block", "width": "32%", "textAlign": "center"}),

        # Predicted Confusion Matrix
        html.Div([
            html.H4("Predicted Confusion Matrix", style={"textAlign": "center", "marginBottom": "10px"}),
            html.Img(id="predicted-number", style={
                "width": "90%", "height": "auto", "margin": "10px", "display": "block"
            }),
            html.Img(id="predicted-percentage", style={
                "width": "90%", "height": "auto", "margin": "10px", "display": "block"
            })
        ], style={"display": "inline-block", "width": "32%", "textAlign": "center"})
    ], style={"textAlign": "center", "marginTop": "20px"})
])


    elif selected_tab == 'optimal-threshold':

        return html.Div([
            html.H4("Select Model for Optimal Threshold Plot"),
            dcc.RadioItems(
                id='model-radio',
                options=[
                    {'label': 'Logistic Regression', 'value': 'logistic_regression'},
                    {'label': 'Decision Tree', 'value': 'decision_tree'},
                    {'label': 'MLP', 'value': 'mlp'},
                    # {"label": "Test Data","value":"Test Data"},
                   #  {'label': 'LightGBM', 'value': 'LightGBM'}
                ],
                value='logistic_regression',  # Default selected value
                labelStyle={'display': 'inline-block', 'margin-right': '20px'}
            ),
            dcc.Graph(id='optimal-threshold-graph')  # Graph to display the plot
        ])


    return html.Div()

def waterfall_chart_column1():
    fig = go.Figure(go.Waterfall(
        name="Variable Reduction",
        orientation="v",
        measure=["absolute", "relative", "relative", "relative", "relative", "relative", "relative", "relative", "relative", "total"],
        x=["LeadSquared", "Exotel", "TataSmartflow", "ID & Date", "Irrelevant Variables", "Missing >80%", "Duplicated Variables", "Columns(Exotel)", "Columns(TataSmartflow)", "Total"],
        textposition="outside",
        text=["+130", "+25", "+35", "-32", "-40", "-38", "-1", "-21", "-36", ""],
        y=[130, 25, 35, -32, -40, -38, -1, -21, -36, 7],  # Adjusted y values with a cumulative total of 7
        connector={"line": {"color": "rgb(63, 63, 63)"}},
        increasing={"marker": {"color": "Teal"}},
        decreasing={"marker": {"color": "Maroon"}},
        totals={"marker": {"color": "Teal", "line": {"color": 'red', "width": 3}}}
    ))

    fig.update_layout(
        title="<b>Variable Reduction (Timeline: 1 April 2023 to 16 September 2024)</b>",
        height=700,
        width=1350,
        title_x=0.45,
        showlegend=True,
        template="plotly_white"
    )
    return fig

def waterfall_chart_row():
    fig = go.Figure(go.Waterfall(
        name="Data Reduction",
        orientation="v",
        measure=["absolute", "relative", "relative", "relative", "relative", "relative", "relative", "total"],
        x=["Total Leads", "Sorting Leads", "Duplicated Records", "Test Leads", "Irrelevant Lead Source",
            "Lead Status- General Enquiry", "Lead Status- Duplicate","Lead Status- Unqualified"],
        textposition="outside",
        text=["1,63,228", "-34,452","-1,346",'-628', "-23,310", "-47,668", "-9,958", "99"],
        y=[163228, -34452,-1346, -628,-23310,-47668, -9958, 99,],
        connector={"line": {"color": "rgb(63, 63, 63)"}},
        increasing={"marker": {"color": "Teal"}},
        decreasing={"marker": {"color": "Maroon"}},
        totals={"marker": {"color": "Teal", "line": {"color": 'red', "width": 3}}},
    ))
    fig.update_layout(title="<b>Data Reduction (Timeline : 1 April 2023 to 29 September 2024)</b>",
    height=700,width=1300, title_x=0.45,showlegend=True,template="plotly_white",)
    return fig

@app.callback(Output('image1-container', 'children'),
    Input('table-rows-option', 'n_clicks'),
    Input('waterfall-chart-option-1', 'n_clicks'),)
def update_first_image(n_clicks_table_rows, n_clicks_waterfall_chart):
    ctx = dash.callback_context
    if not ctx.triggered:
        return html.Img(src='', style={'width': '100%', 'height': 'auto'})
    button_id = ctx.triggered[0]['prop_id'].split('.')[0]
    if button_id == 'table-rows-option':
       return html.Div([
           html.P("LeadSqaured data: "),
           html.Img(src="https://ayurvaidleadscoringmodel.s3.ap-south-1.amazonaws.com/version2/assets/table-row.png", style={'width': '100%', 'height': '80%'}),
           html.P("Call records: "),

      html.Img(src="https://ayurvaidleadscoringmodel.s3.ap-south-1.amazonaws.com/version2/assets/table-row1.png", style={'width': '100%', 'height': '80%'})])

    elif button_id == 'waterfall-chart-option-1':
        return dcc.Graph(figure=waterfall_chart_row())

@app.callback(
    Output('image2-container', 'children'),
    Input('table-column-option', 'n_clicks'),
    Input('waterfall-chart-option-2', 'n_clicks'),
    Input('variable-name-table-option', 'n_clicks')  # New input for the new item
)
def update_second_image(n_clicks_table_column, n_clicks_waterfall_chart, n_clicks_variable_name_table):
    ctx = dash.callback_context
    if not ctx.triggered:
        return html.Div([ html.P("Variables Taken for Modeling: "),
                         html.Img(src='https://ayurvaidleadscoringmodel.s3.ap-south-1.amazonaws.com/version2/assets/modeling_variables.png', style={'width': '100%', 'height': 'auto'})])
    button_id = ctx.triggered[0]['prop_id'].split('.')[0]

    if button_id == 'table-column-option':
        return html.Img(src="https://ayurvaidleadscoringmodel.s3.ap-south-1.amazonaws.com/version2/assets/table-column.png", style={'width': '100%', 'height': '80%'})
    elif button_id == 'waterfall-chart-option-2':
        return dcc.Graph(figure=waterfall_chart_column1())
    elif button_id == 'variable-name-table-option':  # Check for the new item
        return html.Img(src="https://ayurvaidleadscoringmodel.s3.ap-south-1.amazonaws.com/version2/assets/table.png", style={'width': '100%', 'height': '80%'})  # Display the new image

@app.callback(
    Output('image3-container', 'children'),
    Input('class-distribution-option', 'n_clicks'),)

def update_third_image(n_clicks_waterfall_chart):
    ctx = dash.callback_context
    if not ctx.triggered:
        return html.Img(src='', style={'width': '100%', 'height': 'auto'})
    button_id = ctx.triggered[0]['prop_id'].split('.')[0]
    if button_id == 'class-distribution-option':
       return html.Img(src="https://ayurvaidleadscoringmodel.s3.ap-south-1.amazonaws.com/version2/assets/data-aggregation.png", style={'width': '100%', 'height': '80%'})

from dash import Input, Output, html

# AWS S3 Base URL
from flask import send_file, Response
import requests
from dash import Input, Output, html

# AWS S3 Base URL
S3_BASE_URL = "https://ayurvaidleadscoringmodel.s3.ap-south-1.amazonaws.com/version2/assets"

def proxy_s3_html(model):
    """
    Proxy S3 HTML content through the Flask server.
    """
    url_mapping = {
        "logistic_regression": f"{S3_BASE_URL}/Logistic+Regression_threshold.html",
        "decision_tree": f"{S3_BASE_URL}/Decision+Tree_threshold.html",
        "mlp": f"{S3_BASE_URL}/MLP_threshold.html"
    }

    s3_url = url_mapping.get(model)
    if s3_url:
        try:
            response = requests.get(s3_url)
            if response.status_code == 200:
                return Response(response.content, content_type='text/html')
            else:
                return f"Failed to fetch HTML from S3. Status Code: {response.status_code}"
        except Exception as e:
            return f"Error: {e}"
    return "Invalid Model Selected"

@app.callback(
    Output('optimal-threshold-graph', 'children'),
    [Input('model-radio', 'value')]
)
def update_optimal_threshold_plot(selected_model):
    """
    Dynamically display Threshold Plot from S3 via Flask Proxy.
    """
    url_mapping = {
        "logistic_regression": "/s3-proxy/logistic_regression",
        "decision_tree": "/s3-proxy/decision_tree",
        "mlp": "/s3-proxy/mlp"
    }

    proxy_url = url_mapping.get(selected_model)

    if proxy_url:
        print(f"Proxy URL: {proxy_url}")
        return html.Div([
            html.Hr(),
            html.P(f"Displaying Threshold Plot for {selected_model.replace('_', ' ').title()}"),
            html.Iframe(
                src=proxy_url,
                style={
                    "width": "100%",
                    "height": "600px",
                    "border": "none"
                }
            )
        ])
    else:
        return html.Div("Please select a valid model.", style={"textAlign": "center"})


@app.callback(
    Output("lift-chart-container", "children"),
    [Input("model-selection", "value")]
)
def update_lift_chart(selected_model):
    if selected_model == "base-models":
        return html.Div([  html.Hr(),  # Separator line
        html.Iframe(
            src="https://ayurvaidleadscoringmodel.s3.ap-south-1.amazonaws.com/version2/assets/lift_chart.html",  # Update with actual path
            style={"width": "100%", "height": "600px", "border": "none"}
        )])
    elif selected_model == "advanced":
        return html.Div( [html.Hr(),  # Separator line
        html.Iframe(
            src="https://ayurvaidleadscoringmodel.s3.ap-south-1.amazonaws.com/version2/assets/K-S+Chart.html",  # Update with actual path
            style={"width": "100%", "height": "600px", "border": "none"}
        )])
    else:
        return html.Div("Please select a valid model.", style={"textAlign": "center"})
# Callback to update the confusion matrix images based on the selected model
# Mock Environment Variables
S3_BUCKET = "ayurvaidleadscoringmodel"
S3_REGION = "s3.ap-south-1"
CONFUSION_MATRIX_FOLDER = "Confusion Matrix"
# Image Filenames Mapping
image_filenames = {
    "logistic_regression": {
        "train": {"number": "train_confusion_logistic.png", "percentage": "train_confusion_logistic_percent.png"},
        "test": {"number": "test_confusion_logistic.png", "percentage": "test_confusion_logistic_percent.png"},
        "predicted": {"number": "predicted_logistic_num.png", "percentage": "predicted_logistic_percentage.png"}
    },
    "decision_tree": {
        "train": {"number": "train_confusion_decision.png", "percentage": "train_confusion_decision_percent.png"},
        "test": {"number": "test_confusion_decision.png", "percentage": "test_confusion_decision_percent.png"},
        "predicted": {"number": "predicted_decision_tree.png", "percentage": "predicted_decision_percentage.png"}
    },
    "mlp": {
        "train": {"number": "train_confusion_mlp.png", "percentage": "train_confusion_mlp_percent.png"},
        "test": {"number": "test_confusion_mlp.png", "percentage": "test_confusion_mlp_percent.png"},
        "predicted": {"number": "predicted_mlp_num.png", "percentage": "predicted_mlp_percentage.png"}
    }
}

#
# Model Details Mapping
model_details = {
    "logistic_regression": {
        "optimal_threshold": 0.48,
        "train_timeline": "April 1st, 2023 – March 31st, 2024",
        "test_timeline": "April 1st, 2024 – September 29th, 2024",
        "prediction_timeline": "October 1st, 2024 – December 12th, 2024"
    },
    "decision_tree": {
        "optimal_threshold": 0.27,
        "train_timeline": "April 1st, 2023 – March 31st, 2024",
        "test_timeline": "April 1st, 2024 – September 29th, 2024",
        "prediction_timeline": "October 1st, 2024 – December 12th, 2024"
    },
    "mlp": {
        "optimal_threshold": 0.30,
        "train_timeline": "April 1st, 2023 – March 31st, 2024",
        "test_timeline": "April 1st, 2024 – September 29th, 2024",
        "prediction_timeline": "October 1st, 2024 – December 12th, 2024"
    }
}


def generate_s3_url(bucket, key):
    """
    Generate a valid S3 URL for the given key.
    """
    full_key = f"version2/assets/Confusion+Matrix/{key}"
    return f"https://{bucket}.s3.ap-south-1.amazonaws.com/{full_key}"

@app.callback(
    [Output("model-details", "children"),
     Output("train-number", "src"),
     Output("train-percentage", "src"),
     Output("test-number", "src"),
     Output("test-percentage", "src"),
     Output("predicted-number", "src"),
     Output("predicted-percentage", "src")],
    [Input("model-selection-confusion", "value")]
)
def update_model_details_and_confusion_matrices(selected_model):
    """
    Update model details and image URLs dynamically.
    """
    try:
        # Fetch Model Details
        details = model_details[selected_model]
        details_html = html.Div([
            html.P(f"Optimal Threshold: {details['optimal_threshold']}", style={"fontWeight": "bold"}),
            html.P(f"Train Timeline: {details['train_timeline']}", style={"fontWeight": "bold"}),
            html.P(f"Test Timeline: {details['test_timeline']}", style={"fontWeight": "bold"}),
            html.P(f"Prediction Timeline: {details['prediction_timeline']}", style={"fontWeight": "bold"})
        ], style={"textAlign": "center", "marginBottom": "20px"})

        # Generate Image URLs with the corrected folder path
        train_number = generate_s3_url(S3_BUCKET, image_filenames[selected_model]['train']['number'])
        train_percentage = generate_s3_url(S3_BUCKET, image_filenames[selected_model]['train']['percentage'])
        test_number = generate_s3_url(S3_BUCKET, image_filenames[selected_model]['test']['number'])
        test_percentage = generate_s3_url(S3_BUCKET, image_filenames[selected_model]['test']['percentage'])
        predicted_number = generate_s3_url(S3_BUCKET, image_filenames[selected_model]['predicted']['number'])
        predicted_percentage = generate_s3_url(S3_BUCKET, image_filenames[selected_model]['predicted']['percentage'])

        print("Train Number URL:", train_number)
        print("Train Percentage URL:", train_percentage)
        print("Test Number URL:", test_number)
        print("Test Percentage URL:", test_percentage)
        print("Predicted Number URL:", predicted_number)
        print("Predicted Percentage URL:", predicted_percentage)

        return (
            details_html,
            train_number, train_percentage,
            test_number, test_percentage,
            predicted_number, predicted_percentage
        )

    except KeyError as e:
        print(f"KeyError: {e}")
        return (
            html.P("Error: Missing keys in model details or image filenames.", style={"color": "red"}),
            "", "", "", "", "", ""
        )
    except Exception as e:
        print(f"Unexpected Error: {e}")
        return (
            html.P("Error generating model details or URLs.", style={"color": "red"}),
            "", "", "", "", "", ""
        )



if __name__ == "__main__":
    app.run_server(debug=True, port=8050)

